package UI::GTKOutput;

use strict;

my %buffer; # hash of page buffers
my %pages;  # hash of generated pages

my $output; # pointer to hold content generated by this object

my $basedir="@datadir@";
my $outputdir = "/var/log/wicrawl";

sub generate {
	$output = Gtk2::Notebook->new;
	UI::GTKOutput->add_page("Output");
	return $output;
}

sub add_page {
	shift;
	my ($title) = @_;

	# Output Frame
	my $frame = Gtk2::Frame->new;

	# Output Scrolled Window
	my $sw = Gtk2::ScrolledWindow->new (undef, undef);
	$sw->set_shadow_type ('etched-out');
	$sw->set_policy ('automatic', 'automatic');
	$sw->set_size_request (800,200);

	# Creates view window and sets properties
	my $tview = Gtk2::TextView->new();
	$tview->set_editable(0);
	$tview->set_cursor_visible(0);
	$tview->set_wrap_mode("word");

	# Set initial view window content
	my $buffer = $tview->get_buffer();
	$buffer->create_tag ("black", justification => "left");
 	$buffer->create_tag ("orange", foreground => "orange");
 	$buffer->create_tag ("red", foreground => "red");

	# every  time we insert text, scroll to that mark
	my $end_mark = $buffer->create_mark('end', $buffer->get_end_iter, 0);
	$buffer->signal_connect (insert_text=>sub {
		$tview->scroll_to_mark ($end_mark, 0.0, 1, 0.0, 0.5);
	});

	# Save buffer to the hash
	$buffer{$title} = $buffer;

	$sw->add($tview);
	$frame->add($sw);

	# Save page pointer to the hash
	$pages{$title} = $frame;

	# Append newly generated page to output notebook
	unless($title eq 'Output') { $title = "Plugin Output($title)"; }
	$output->append_page($frame, Gtk2::Label->new($title));
	$output->show_all;

}

sub remove_page {
	shift;
	my ($title) = @_;

	# Remove page from output notebook
	my $frame = $pages{$title};
	$output->remove_page($output->page_num($frame));
	delete $pages{$title};

	# Remove buffer from hash
	delete $buffer{$title};	

}

#######################################################################
# function lprint - log print function
# 	Arugments: type of buffer, message (int), loglevel (int), string of $msg
#		Returns: 0
#		Notes:  
#			Loglevels are:
#				0 = Errors and fatal  (Always shown, -q for quiet)
#				1 = Default logging   (default log level)
#				2 = More info  				(-v)
#				3 = All info          (-vv)
#			Message Types are:
#				0 = Info (black)
#				1 = Notice (orange)
#				2 = Error (red)
####################
sub lprint {
	shift;
	my ($type,$loglevel,$msg,$title) = @_;

	# try to print to appropriate interface output or else
	# just print to standard output
	unless(defined $title) {
		$title = "Output";
	}

	my $buffer = $buffer{$title};
	
 	my $color="black";

	# set the prefix character: '!' is err, '*' is notice
	if ($type == 1) {
		$color="orange";
	}	elsif ($type == 2) {
		$color="red";
	}

	my $verbosity = 3;

	# print if loglevel is high enough
	if($loglevel <= $verbosity) {
		$buffer->insert_with_tags_by_name ($buffer->get_end_iter, $msg, $color);
	}
	
	return 0;
}

#######################################################################
# function show_data - prints data from interfaces
# 	Arugments:
#		Returns:
####################
sub show_data {
	my $interface = UI::Common->interface;
	foreach my $int (keys %$interface) {
		if($$interface{$int} && $int ne 'monitor') {
			# we only want to read file if it was already created by the plugin-engine
			if (-e "$outputdir/$int") {
				open(INT, "$outputdir/$int") || UI::GTKOutput->lprint(2,3,"Couldn't open $outputdir/$int\n",$int);
				$buffer{$int}->set_text("");
				while(<INT>) { UI::GTKOutput->lprint(0,3,$_,$int); }
				close INT;
			}
		}
	}
}

sub show {
	$output->show_all;
}

sub hide {
	$output->hide_all;

	# Perform window resizing
	my $window = $output->get_parent->get_parent->get_parent;
	my ($width, $height) = $window->get_size;
	$window->resize($width, $height - 220);
}

1;
